<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>c2tool</title>
    <style>
        p {
            margin: 0;
        }

        .row {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
        }
    </style>
</head>
<body>
    <h3>c2tool</h3>
    <div class="row">
        <button onclick="connect()">Connect</button>
        <p id="deviceStatus"></p>
    </div>
    <div class="device">

    </div>
    <script>
        const EXTENDED_FRAME_START_FLAG = 0xf0;
        const STANDARD_FRAME_START_FLAG = 0xf1;
        const STOP_FRAME_FLAG = 0xf2;
        const BYTE_STUFFING_FLAG = 0xf3;

        const commands = {
            CSAFE_GETSTATUS_CMD: [0x80, []],
            CSAFE_RESET_CMD: [0x81, []],
            CSAFE_GOIDLE_CMD: [0x82, []],
            CSAFE_GOHAVEID_CMD: [0x83, []],
            CSAFE_GOINUSE_CMD: [0x85, []],
            CSAFE_GOFINISHED_CMD: [0x86, []],
            CSAFE_GOREADY_CMD: [0x87, []],
            CSAFE_BADID_CMD: [0x88, []],
            CSAFE_GETVERSION_CMD: [0x91, []],
            CSAFE_GETID_CMD: [0x92, []],
            CSAFE_GETUNITS_CMD: [0x93, []],
            CSAFE_GETSERIAL_CMD: [0x94, []],
            CSAFE_GETODOMETER_CMD: [0x9B, []],
            CSAFE_GETERRORCODE_CMD: [0x9C, []],
            CSAFE_GETTWORK_CMD: [0xA0, []],
            CSAFE_GETHORIZONTAL_CMD: [0xA1, []],
            CSAFE_GETCALORIES_CMD: [0xA3, []],
            CSAFE_GETPROGRAM_CMD: [0xA4, []],
            CSAFE_GETPACE_CMD: [0xA6, []],
            CSAFE_GETCADENCE_CMD: [0xA7, []],
            CSAFE_GETUSERINFO_CMD: [0xAB, []],
            CSAFE_GETHRCUR_CMD: [0xB0, []],
            CSAFE_GETPOWER_CMD: [0xB4, []],

            CSAFE_AUTOUPLOAD_CMD: [0x01, [1,]],    // Configuration (no affect)
            CSAFE_IDDIGITS_CMD: [0x10, [1,]],      // Number of Digits
            CSAFE_SETTIME_CMD: [0x11, [1, 1, 1]],  // Hour, Minute, Seconds
            CSAFE_SETDATE_CMD: [0x12, [1, 1, 1]],  // Year, Month, Day
            CSAFE_SETTIMEOUT_CMD: [0x13, [1,]],    // State Timeout
            CSAFE_SETUSERCFG1_CMD: [0x1A, [0,]],   // PM3 Specific Command (length computed)
            CSAFE_SETTWORK_CMD: [0x20, [1, 1, 1]], // Hour, Minute, Seconds
            CSAFE_SETHORIZONTAL_CMD: [0x21, [2, 1]], // Distance, Units
            CSAFE_SETCALORIES_CMD: [0x23, [2,]],   // Total Calories
            CSAFE_SETPROGRAM_CMD: [0x24, [1, 1]],  // Workout ID, N/A
            CSAFE_SETPOWER_CMD: [0x34, [2, 1]],    // Stroke Watts, Units
            CSAFE_GETCAPS_CMD: [0x70, [1,]],       // Capability Code

            CSAFE_PM_GET_WORKOUTTYPE: [0x89, [], 0x1A],
            CSAFE_PM_GET_DRAGFACTOR: [0xC1, [], 0x1A],
            CSAFE_PM_GET_STROKESTATE: [0xBF, [], 0x1A],
            CSAFE_PM_GET_WORKTIME: [0xA0, [], 0x1A],
            CSAFE_PM_GET_WORKDISTANCE: [0xA3, [], 0x1A],
            CSAFE_PM_GET_ERRORVALUE: [0xC9, [], 0x1A],
            CSAFE_PM_GET_WORKOUTSTATE: [0x8D, [], 0x1A],
            CSAFE_PM_GET_WORKOUTINTERVALCOUNT: [0x9F, [], 0x1A],
            CSAFE_PM_GET_INTERVALTYPE: [0x8E, [], 0x1A],
            CSAFE_PM_GET_RESTTIME: [0xCF, [], 0x1A],

            CSAFE_PM_SET_SPLITDURATION: [0x05, [1, 4], 0x1A], // Time(0)/Distance(128), Duration
            CSAFE_PM_GET_FORCEPLOTDATA: [0x6B, [1,], 0x1A],   // Block Length
            CSAFE_PM_SET_SCREENERRORMODE: [0x27, [1,], 0x1A], // Disable(0)/Enable(1)
            CSAFE_PM_GET_HEARTBEATDATA: [0x6C, [1,], 0x1A],   // Block Length
        }

        const responses = {
            0x80: ['CSAFE_GETSTATUS_CMD', [0,]],        // Status
            0x81: ['CSAFE_RESET_CMD', [0,]],
            0x82: ['CSAFE_GOIDLE_CMD', [0,]],
            0x83: ['CSAFE_GOHAVEID_CMD', [0,]],
            0x85: ['CSAFE_GOINUSE_CMD', [0,]],
            0x86: ['CSAFE_GOFINISHED_CMD', [0,]],
            0x87: ['CSAFE_GOREADY_CMD', [0,]],
            0x88: ['CSAFE_BADID_CMD', [0,]],
            0x91: ['CSAFE_GETVERSION_CMD', [1, 1, 1, 2, 2]], // Mfg ID, CID, Model, HW Version, SW Version
            0x92: ['CSAFE_GETID_CMD', [-5,]],           // ASCII Digit (variable)
            0x93: ['CSAFE_GETUNITS_CMD', [1,]],         // Units Type
            0x94: ['CSAFE_GETSERIAL_CMD', [-9,]],       // ASCII Serial Number
            0x9B: ['CSAFE_GETODOMETER_CMD', [4, 1]],    // Distance, Units Specifier
            0x9C: ['CSAFE_GETERRORCODE_CMD', [3,]],     // Error Code
            0xA0: ['CSAFE_GETTWORK_CMD', [1, 1, 1]],    // Hours, Minutes, Seconds
            0xA1: ['CSAFE_GETHORIZONTAL_CMD', [2, 1]],  // Distance, Units Specifier
            0xA3: ['CSAFE_GETCALORIES_CMD', [2,]],      // Total Calories
            0xA4: ['CSAFE_GETPROGRAM_CMD', [1,]],       // Program Number
            0xA6: ['CSAFE_GETPACE_CMD', [2, 1]],        // Stroke Pace, Units Specifier
            0xA7: ['CSAFE_GETCADENCE_CMD', [2, 1]],     // Stroke Rate, Units Specifier
            0xAB: ['CSAFE_GETUSERINFO_CMD', [2, 1, 1, 1]], // Weight, Units Specifier, Age, Gender
            0xB0: ['CSAFE_GETHRCUR_CMD', [1,]],         // Beats/Min
            0xB4: ['CSAFE_GETPOWER_CMD', [2, 1]],       // Stroke Watts
            
            0x01: ['CSAFE_AUTOUPLOAD_CMD', [0,]],
            0x10: ['CSAFE_IDDIGITS_CMD', [0,]],
            0x11: ['CSAFE_SETTIME_CMD', [0,]],
            0x12: ['CSAFE_SETDATE_CMD', [0,]],
            0x13: ['CSAFE_SETTIMEOUT_CMD', [0,]],
            0x1A: ['CSAFE_SETUSERCFG1_CMD', [0,]],      // PM3 Specific Command ID
            0x20: ['CSAFE_SETTWORK_CMD', [0,]],
            0x21: ['CSAFE_SETHORIZONTAL_CMD', [0,]],
            0x23: ['CSAFE_SETCALORIES_CMD', [0,]],
            0x24: ['CSAFE_SETPROGRAM_CMD', [0,]],
            0x34: ['CSAFE_SETPOWER_CMD', [0,]],
            0x70: ['CSAFE_GETCAPS_CMD', [11,]],         // Depended on Capability Code (variable)

            0x1A89: ['CSAFE_PM_GET_WORKOUTTYPE', [1,]], // Workout Type
            0x1AC1: ['CSAFE_PM_GET_DRAGFACTOR', [1,]],  // Drag Factor
            0x1ABF: ['CSAFE_PM_GET_STROKESTATE', [1,]], // Stroke State
            0x1AA0: ['CSAFE_PM_GET_WORKTIME', [4, 1]],
            0x1AA3: ['CSAFE_PM_GET_WORKDISTANCE', [4, 1]],
            0x1AC9: ['CSAFE_PM_GET_ERRORVALUE', [2,]],  // Error Value
            0x1A8D: ['CSAFE_PM_GET_WORKOUTSTATE', [1,]], // Workout State
            0x1A9F: ['CSAFE_PM_GET_WORKOUTINTERVALCOUNT', [1,]], // Workout Interval Count
            0x1A8E: ['CSAFE_PM_GET_INTERVALTYPE', [1,]], // Interval Type
            0x1ACF: ['CSAFE_PM_GET_RESTTIME', [2,]],    // Rest Time

            0x1A05: ['CSAFE_PM_SET_SPLITDURATION', [0,]], // No variables returned !! double check
            0x1A6B: ['CSAFE_PM_GET_FORCEPLOTDATA', [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]], // Bytes read, data ...
            0x1A27: ['CSAFE_PM_SET_SCREENERRORMODE', [0,]],  // No variables returned !! double check
            0x1A6C: ['CSAFE_PM_GET_HEARTBEATDATA', [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]], // Bytes read, data ...
        }

        const $i = id => document.getElementById(id);

        const deviceStatus = $i("deviceStatus");
        let device;

        if (navigator.usb === undefined) {
            alert("WebUSB is not supported in this browser, please use the latest version of any Chromium-based browser (Chrome, Edge, Brave, etc.)");
        }

        async function connect() {
            deviceStatus.innerText = "Waiting for selection...";

            try {
                device = await navigator.usb.requestDevice({ filters: [{ vendorId: 6052 }] });
            } catch (e) {
                deviceStatus.innerText = "Device selection canceled";
                console.warn(e);
                return;
            }
            
            deviceStatus.innerText = `Connecting to ${device.manufacturerName} ${device.productName}...`
            console.log(device);
            console.log(device.productName);
            console.log(device.manufacturerName);
        }

        function popAt(arr, index) {
            const i = Math.floor(index);
            if (i < 0 || i >= arr.length) return undefined;

            const removed = arr[i];
            for (let j = i; j < arr.length - 1; j++) {
                arr[j] = arr[j + 1];
            }

            arr.length = arr.length - 1;
            return removed;
        }

        function checkMessage(message) {
            let i = 0;
            let checksum = 0;

            while (i < message.length) {
                if (message[i] === BYTE_STUFFING_FLAG) {
                    let stuffValue = popAt(message, i + 1);
                    message[i] = 0xf0 | stuffValue;
                }

                checksum = checksum ^ message[i];
                i++;
            }

            if (checksum !== 0) {
                console.warn(`Checksum error: ${checksum}`);
                return [];
            }

            delete message[message.length - 1];
            return message;
        }

        function write(args) {
            let message = [];
            let i = 0;
            let wrapper = 0;
            let wrapped = [];
            let maxResponse = 3;

            while (i < args.length) {
                let arg = args[i];
                let cmdProp = commands[arg];
                let command = [];

                if (cmdProp[1].length !== 0) {
                    cmdProp[1].forEach(varBytes => {
                        i++;
                        let intValue = args[i];
                        let value = intToBytes(varBytes, intValue);
                        command.push(value);
                    })

                    let cmdBytes = command.length
                    command.unshift(cmdBytes);
                }

                command.unshift(cmdProp[0]);

                if (cmdProp.length > 0 && (cmdProp.length < 3 || cmdProp[2] !== wrapper)) {
                    wrapped.unshift(wrapped.length);
                    wrapped.unshift(wrapper);
                    message.push(wrapped);
                    wrapped = [];
                    wrapper = 0;
                }

                if (cmdProp.length === 3) {
                    if (wrapper === cmdProp[2]) {
                        wrapped.push(command);
                    } else {
                        wrapped = command;
                        wrapper = cmdProp[2];
                        maxResponse += 2;
                    }

                    command = [];
                }

                let cmdId = cmdProp[0] | (wrapper << 8);
                maxResponse += Math.abs(responses[cmdId][1].reduce((a, b) => a + b, 0));
                message.push(command);
                i++;
            }

            if (wrapped.length > 0) {
                wrapped.unshift(wrapped.length);
                wrapped.unshift(wrapper);
                message.push(wrapped);
            }

            let checksum = 0;
            let j = 0;

            while (j < message.length) {
                checksum = checksum ^ message[j]

                if (0xf0 <= message[j] <= 0xf3) {
                    message.splice(j, 0, BYTE_STUFFING_FLAG);
                    j++;
                    message[j] = message[j] & 0x3;
                }

                j++;
            }

            message.push(checksum);
            message.unshift(STANDARD_FRAME_START_FLAG);
            message.append(STOP_FRAME_FLAG);

            if (message.length > 96) {
                console.warn(`Message is too long: ${message.length} > 96 bytes`);
            }

            let maxMessage = Math.max(message.length + 1, maxResponse);

            if (maxMessage > 21) {
                message.unshift(0x01);
                for (let n = 0; n < 21 - message.length; n++) {
                    message.push(0);
                }
            } else if (maxMessage <= 63) {
                message.unshift(0x04);
                for (let n = 0; n < 63 - message.length; n++) {
                    message.push(0);
                }
            } else if (message.length + 1 <= 121) {
                message.unshift(0x02);
                for (let n = 0; n < 121 - message.length; n++) {
                    message.push(0);
                }
                if (maxResponse > 121) {
                    console.warn(`Response may be too long to receive. Max possible length: ${maxResponse}.`)
                }
            } else {
                console.warn(`Message is too long: ${message.length} > 121 bytes`);
                message = [];
            }

            return message;
        }

        function read(transmission) {
            let message = [];
            let stopFound = false;
            let startFlag = transmission[1];
            let j;

            if (startFlag === EXTENDED_FRAME_START_FLAG) {
                j = 4;
            } else if (startFlag === STANDARD_FRAME_START_FLAG) {
                j = 2;
            } else {
                console.warn("No start flag found");
                return [];
            }

            while (j < transmission.length) {
                if (transmission[j] === STOP_FRAME_FLAG) {
                    stopFound = true;
                    break;
                }

                message.push(transmission[j]);
                j++;
            }

            if (!stopFound) {
                console.warn("No stop flag found");
                return [];
            }

            message = checkMessage(message);
            let status = popAt(message, 0);

            let response = {
                CSAFE_GETSTATUS_CMD: [status]
            }
            let k = 0;
            let wrapend = -1;
            let wrapper = 0x0;

            while (k < message.length) {
                let result = [];

                let msgCmd = message[k];
                if (k <= wrapend) {
                    msgCmd = wrapper | msgCmd;
                }

                let msgProp = responses[msgCmd];
                k++;

                let byteCount = message[k];
                k++;

                if (msgProp[0] === "CSAFE_GETSTATUS_CMD") {
                    wrapper = message[k - 2] << 8;
                    wrapend = k + byteCount - 1;
                    if (byteCount > 0) {
                        msgCmd = wrapper | message[k];
                        msgProp = responses[msgCmd];
                        k++;
                        byteCount = message[k];
                        k++;
                    }
                }

                if (msgProp[0] === "CSAFE_GETCAPS_CMD") {
                    msgProp[1] = [];
                    for (let n = 0; n < byteCount; n++) {
                        msgProp[1].push(1);
                    }
                }

                if (msgProp[0] === "CSAFE_GETID_CMD") {
                    msgProp[1] = [-byteCount];
                }

                if (Math.abs(msgProp[1].reduce((a, b) => a + b, 0)) !== 0 && byteCount !== Math.abs(msgProp[1].reduce((a, b) => a + b, 0))) {
                    console.warn("Bytecount is an unexpected length");
                }

                msgProp[1].forEach(numBytes => {
                    let rawBytes = message.slice(k, k + numBytes);
                    let value;
                    if (numBytes >= 0) {
                        value = bytesToInt(rawBytes);
                    } else {
                        value = bytesToAscii(rawBytes);
                    }
                    result.push(value);
                    k += Math.abs(numBytes);
                });

                response[msgProp[0]] = result;
            }

            return message;
        }
    </script>
</body>
</html>